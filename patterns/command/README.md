# 커맨드 패턴(Command Pattern)

## 개념

### Head First 디자인 패턴

커맨드 패턴(Command Pattern)을 사용하면 요청 내역을 객체로 갭슐화해서 객체를 서로 다른 요청 내역에 따라 매개변수화할 수 있습니다. 이러면 요청을 큐에 저장하거나 로그로 기록하거나 작업 취소 기능을 사용할 수 있습니다.

### GoF의 디자인 패턴

요청을 객체의 형태로 캡슐화하여 서로 요청이 다른 사용자의 매개변수화, 요청 저장 또는 로깅, 그리고 연산의 취소를 지원하게 만드는 패턴입니다.

### refactoring.guru

커맨드는 요청을 요청에 대한 모든 정보가 포함된 독립실행형 객체로 변환하는 행동 디자인 패턴입니다. 이 변환은 다양한 요청들이 있는 메서드들을 인수화 할 수 있도록 하며, 요청의 실행을 지연 또는 대기열에 넣을 수 있도록 하고, 또 실행 취소할 수 있는 작업을 지원할 수 있도록 합니다.

## 설명

관심사 분리 원칙을 기반으로, 대표적으로 사용자 인터페이스와 비즈니스 로직을 분리하는 것을 제안하는 패턴

주로 큐에 담아 개별적으로 실행 전략을 관리하려고 하는 경우, 혹은 원격으로 각기 개별적인 실행이 필요할 경우 주로 사용하게 되는 패턴이다. 특정 메소드 호출을 독립실행형 객체로 전환하여, 이 전환을 통해 얻은 커맨드를 메소드 인수들로 전달하거나 다른 객체(인보커) 내부에 저장하고 관리하여, 런타임에서 다양한 커맨드를 변경하고 개별적으로 실행하는 등 유연하게 작업을 나눌 수 있게 된다. 또 실행된 커맨드를 비교적 수월하게 직렬화할 수 있기 때문에, 작업을 분실했을 경우 직렬화된 데이터를 통해 데이터를 복원하는 것도 가능하다. 이런 독립적인 실행 제어 속성 덕분에 서비스 상태에 따라 지연이 발생하거나, 예약 실행이 필요한 경우 등에도 모두 대처가 가능하여 활용도가 높다.

각 작업이 개별적으로 다루어지기 때문에 실행한 작업을 실행 취소할 수 있게 된다. 개발 환경 및 구현 방식에 따라 실행 취소 / 재실행 제한이 달라지기에 필요에 따라 구현하면 된다.

커맨드 패턴을 제대로 다루게 된다면, 메타 커맨드 패턴(Meta Command Pattern)도 어렵지 않게 구현할 수 있다. 이 패턴을 사용하면 여러 명령을 매크로로 처리하여 한 번에 실행할 수 있게 된다.

### 패턴 구조

1. 클라이언트에서 커맨드 구상 클래스(커맨드 객체, ConcreateCommand)를 생성한다.

2. 커맨드 구상 클래스는 특정 객체(리시버)가 특정 작업을 할 수 있도록 구성하고 캡슐화한다. 행동과 리시버의 정보로 구성된다.

3. 커맨드 구상 클래스에서 제공하는 메소드는 일반적으로 매개변수를 받지 않는 execute() 메소드뿐이다.
   이 메소드는 행동을 캡슐화하여 리시버에 행동을 요청한다.

4. 클라이언트는 인보커(발송자 클래스, Invoker)에서 제공하는 setCommand() 메소드를 통해 사용할 커맨드 구상 클래스를 전달한다. 전달받은 커맨드 구상 클래스는 인보커에서 관리하게 된다.

5. 클라이언트에서 인보커를 통해 관리 중인 커맨드 구상 클래스에 execute() 실행 요청을 보낸다.

6. 인보커에 등록된 커맨드 구상 클래스는 execute() 메소드 내부에서, 참조하고 있는 리시버에 기술된 행동을 요청한다.

### 구현 방법

1. execute, undo 등 실행 메소드를 기술한 커맨드 인터페이스를 선언한다.

2. 모든 커맨드 구상 클래스는 커맨드 인터페이스를 통해 구현한다. 이 구상 클래스 내부에는 실제 행동을 수행할 리시버(수신자) 객체에 대한 참조도 포함된다.

3. 인보커(발송자) 클래스를 구성해야 한다. 인보커 내부에는 제어 대상인 커맨드 구상 클래스를 참조하고 제어할 수 있도록 관리해야 한다. 일반적으로 인보커 내부에서 커맨드 구상 클래스(객체)를 생성하지 않고, 클라이언트를 통해 커맨드 구상 클래스를 전달받는다.

4. 인보커에서 리시버를 직접 호출하지 않고, 리시버를 참조하는 커맨드 구상 클래스를 통해 요청을 제어한다.

5. 클라이언트에서 다음 순서로 객체들을 초기화한다.
   1. 리시버를 만든다.
   2. 커맨드 구상 클래스를 통해 연관 리시버와 연동하여 커맨드 객체를 만든다.
   3. 생성한 커맨드 객체를 인보커에 등록한다.

### 장점

- 단일 책임 원칙, 작업을 호출한 클래스(클라이언트)와 작업을 수행하는 클래스(리시버)를 분리할 수 있다.

- 개방/폐쇄 원칙, 기존 클라이언트 코드를 변경하지 않은 채 커맨드 수정을 유연하게 할 수 있다.

- 실행 취소 및 재실행을 구현할 수 있다.

- 작업(커맨드)을 지연, 예약 등 유연하게 다룰 수 있게 된다.

- 각종 커맨드를 종합하여 복잡한 커맨드로 조합할 수 있다.

### 단점

- 클라이언트와 작업을 수행하는 대상(리시버) 사이에 별도의 계층(인보커, 커맨드 구상 클래스)이 생기므로 복잡도가 높아진다.
