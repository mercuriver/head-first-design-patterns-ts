[작성 중]

# 데코레이터 패턴 (Decoractor Pattern)

## 개념

### Head First 디자인 패턴

데코레이터 패턴(Decoractor Pattern)으로 객체에 추가 요소를 동적으로 더할 수 있습니다. 데코레이터를 사용하면 서브클래스를 만들 때보다 훨씬 유연하게 기능을 확장할 수 있습니다.

### GoF의 디자인 패턴

장식자(Decoractor) 패턴, 주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙히는 패턴으로, 기능 확장이 필요할 때 서브클래싱 대신 쓸 수 있는 유연한 대안이 될 수 있습니다.

## 요약

- 슈퍼클래스로는 행동을 상속받기 위함이 아니라 형식을 맞추기 위해 사용된다.

- 데코레이터의 슈퍼클래스는 자신이 장식하고 있는 객체의 슈퍼클래스와 같다. 즉, 데코레이터 클래스와 그 클래스가 감싸야하는 구성 요소는 서로 같은 형식이다. 상속이나 인터페이스 구현으로 자신이 감쌀 구성 요소와 같은 형식이여야 한다.

- 데코레이터는 자기가 감싸고 있는 구성 요소의 메소드를 호출한 결과에 새로운 기능으로 더함으로써 행동을 확장한다.

- 구성 요소의 클라이언트는 데코레이터의 존재를 알 수 없다.

- 한 객체를 여러 개의 데코레이터로 감쌀 수 있다. 개수에는 제한이 없다.

- 데코레이터는 자신이 감싸고 있는 객체와 같은 슈퍼클래스를 사용하기 때문에 원래 객체(감싸고 있는 객체)를 대신하여 데코레이터 객체가 들어가도 문제 없다.

- 자신이 감싸고 있는 객체에게 어떤 행동을 위임하는 것 말고도 추가 작업을 할 수 있다.

- 객체를 언제든 감쌀 수 있으므로 실행 중에 필요한 데코레이터를 동적으로 추가할 수 있다.

- 데코레이터 패턴은 감싸고 있는 객체에 행동을 추가하는 용도로 사용되며, 데코레이터를 통해 특정 작업을 해야할 경우, 데코레이터 패턴의 의도와 어긋나게 됩니다.

- 데코레이터 패턴을 쓸 경우 관리 대상(객체)가 늘어남에 따라 유지보수 비용이 증가할 수 있다, 하지만 실제로는 팩토리나 빌더 같은 다른 패턴을 통해 데코레이터를 사용하기 때문에 데코레이터로 장식된 구상 구성 요소는 캡슐화되어 유지보수 관점에서 보다 자유로워진다.

## 설명

마치 마트료시카와 같이 자가 중첩 형태를 띄는 패턴

재사용 효율을 높히기 위해서는 상속, 구성과 위임 등을 활용해야 한다. 상속을 통해 행동을 결정하면 컴파일 시점에서 모든게 결정이고 모든 서브클래스에서 똑같은 행동을 상속받아야 한다. 하지만 구성으로 객체의 행동을 확장하면 실행 중에 동적으로 행동을 설정할 수 있다. 이 방식을 통해 슈퍼클래스의 클래스 코드를 수정하지 않고도 새로운 내용을 거듭 추가할 수 있다.

디자인의 유연성 면에서 상속으로 확장하는 일은 별로 좋은 선택이 아니다. 상속 대신 데코레이터 패턴을 통해 행동을 확장할 수 있다.

- 디자인 원칙 [5], [클래스는 확장에는 열려 있어야 하지만 변경에는 닫혀 있어야 한다(OCP)]

### v2

예제 코드는 base/v2로 나뉘며, v2는 음료 선언을 위한 중복 코드 개선 및 데코레이터 호출 시 표현력을 개선하기 위해 'add' 메소드를 추가하여, 이를 통한 메소드 체인을 구현한 예제 코드다.

#### 주요 코드

<pre><code>
interface BeverageDecoratorClass {
  new (beverage: BeverageDecorator): BeverageDecorator;
}

class BeverageDecorator {
  #beverage: BeverageDecorator;

  constructor(beverage?: BeverageDecorator) {
    this.#beverage = beverage;
  }

  ...

  add(beverageDecorator: BeverageDecoratorClass) {
    return new beverageDecorator(this);
  }
}
</code></pre>

### 단점

- 너무 많은 클래스로 인해 유지보수 비용이 증가하며 이해하기 힘든 디자인이 될 여지가 있다.
