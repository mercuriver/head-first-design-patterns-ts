[작성 중]

# 팩토리 패턴 (Factory Pattern)

팩토리 매소드 패턴의 목적, 어떤 인스턴스 생성의 책임을 구체적인 클래스가 아닌 추상적인 인터페이스의 메소드로 감싸는 것

구상 클래스를 통해 구현하면 새로운 구상 클래스가 추가될 때 마다 연관 코드를 함께 수정해야 하여 유지보수가 어려워 진다, 즉 변경에 닫혀 있음 뜻한다. 새로운 구상 형식을 사용하여 쉽게 확장할 수 있도록 구조를 개선해야하며, 그러기 위해선 인터페이스에 맞추어 구현하면 된다. 특정 인터페이스만 구현하면 다형성을 활용하여 어떤 클래스든 쉽게 확장 가능하다. 이런 확장성을 곧 [변경에 열려 있음]을 뜻한다.

객체 생성을 담당하는 클래스를 팩토리(Factory)라 부르며, 전체 맥락은 이 팩토리와 팩토리를 호출하여 사용하는 클라이언트 부분을 명확하게 나눔으로써 의존성을 분리하는 것 관건이다. 이를 느슨한 결합이라 한다.

예제에서 팩토리(PizzaStore.createPizza)에서 중요한 것은 객체를 만드는 구성 클래스를 선택하는 것이고, 클라이언트(PizzaStore.orderPizza)는 Pizza 인터페이스를 통해서 반환받은 객체를 사용하기 때문에, 향후 Pizza 인터페이스에 맞추어진 그 어떤 구상 클래스가 orderPizza에서 사용되더라도, orderPizza의 코드를 수정할 필요 없이 유연하게 확장 가능하게 된다.
객체 구현 방법 변경에 따라 구상 클래스가 수정/확장되더라도, 인터페이스 양식에 변화만 없다면 팩토리 내부에서 다루는 구상 클래스에만 코드 변화가 생길 뿐, 클라이언트는 그 어떤 영향도 받지 않는다.

클라이언트에서는 전달받은 팩토리를 통해, 팩토리 내부에서 사용할 구성 요소를 접근하여 코드를 기술하면, 향후 기능이 추가되더라도 팩토리에서 변화가 발생하더라도, 인터페이스에 변화가 없는 한, 팩토리를 전달받은 클라이언트에서는 전혀 변화가 필요 없다.

### 주의 1

인터페이스를 통한 구현이란 꼭 interface/implements 키워드를 통한 구현으로 제한하는 것이 아닌, 디자인 원칙 [2]의 상위 형식에 맞춰 프로그래밍하여 다형성을 적극 활용하는 것을 뜻 한다.

### 주의 2

이 문서에서는 객체와 인스턴스라는 표현이 혼용되어 사용 됨. (가급적 책에서 사용된 표현을 택함)

중요한 점은 제품군과 생산부 각각 클래스나 인터페이스를 통한 계층 구조를 확보한 후 이를 클래스화하는 부분, 반드시 추상 클래스나 인터페이스를 통해 구현해야한다는 제한이 있는 것이 아니기 때문에 개발 여건에 따라 다소 변형이 가능.

일종의 의존성주입(디펜던시 인젝션) 이라고 볼수있다. 구현 방식에 따라 다소 차이가 있지만 공통적으로 PizzaStore.orderPizza 내부는 피자에 의존적이지 않은 상태를 유지할 수 있다. (독립적)
orderPizza는 인터페이스로 구현된 pizza를 통해 기술되어, 이후에 피자에 대한 명세가 변경되더라도 orderPizza 코드에는 영향을 주지 않을 수 있어 유연성을 갖게 된다.

이 저장소에서는 본서에서 한 챕터로 엮어 다루는 팩토리 메소드 패턴과 추상 팩토리 패턴을 분리하여 문서로 나눔

## 하위 페이지

- [간단한 팩토리 / Simple Factory](./simpleFactory/)
- [팩토리 메소드 패턴 / Factory Method Pattern](./factoryMethodPattern/)
- [추상 팩토리 패턴 / Abstract Factory Pattern](./abstractFactoryPattern/)
