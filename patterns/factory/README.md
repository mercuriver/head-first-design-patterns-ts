[작성 중]

# 팩토리 패턴 (Factory Pattern)

## 개념

### Head First 디자인 패턴

팩토리 메소드 패턴(Factory Method Pattern)에서는 객체를 생성할 때 필요한 인터페이스를 만듭니다. 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정합니다. 팩토리 메소드 패턴을 사용하면 클래스 인스턴스 만드는 일을 서브클래스에게 맡기게 됩니다.

---

간단한 팩토리 패턴
하나의 구현체를 두고, 구현체 하나에서 여러 다른 제품을 만들어주는 형태

---

팩토리 매소드 패턴의 목적, 어떤 인스턴스 생성의 책임을 구체적인 클래스가 아닌 추상적인 인터페이스의 메소드로 감싸는 것

구상 클래스를 통해 구현하면 새로운 구상 클래스가 추가될 때 마다 연관 코드를 함께 수정해야 하여 유지보수가 어려워 진다, 즉 변경에 닫혀 있음 뜻한다. 새로운 구상 형식을 사용하여 쉽게 확장할 수 있도록 구조를 개선해야하며, 그러기 위해선 인터페이스에 맞추어 구현하면 된다. 특정 인터페이스만 구현하면 다형성을 활용하여 어떤 클래스든 쉽게 확장 가능하다. 이런 확장성을 곧 [변경에 열려 있음]을 뜻한다.

객체 생성을 담당하는 클래스를 팩토리(Factory)라 부르며, 전체 맥락은 이 팩토리와 팩토리를 호출하여 사용하는 클라이언트 부분을 명확하게 나눔으로써 의존성을 분리하는 것 관건이다. 이를 느슨한 결합이라 한다.

예제에서 팩토리(PizzaStore.createPizza)에서 중요한 것은 객체를 만드는 구성 클래스를 선택하는 것이고, 클라이언트(PizzaStore.orderPizza)는 Pizza 인터페이스를 통해서 반환받은 객체를 사용하기 때문에, 향후 Pizza 인터페이스에 맞추어진 그 어떤 구상 클래스가 orderPizza에서 사용되더라도, orderPizza의 코드를 수정할 필요 없이 유연하게 확장 가능하게 된다.
객체 구현 방법 변경에 따라 구상 클래스가 수정/확장되더라도, 인터페이스 양식에 변화만 없다면 팩토리 내부에서 다루는 구상 클래스에만 코드 변화가 생길 뿐, 클라이언트는 그 어떤 영향도 받지 않는다.

@@@ SimpleFactory
간단한 팩토리(Simple Factory)는 패턴이라기 보다는 프로그래밍 관용구에 가까운 구현 기법.
구상 클래스를 사용하는 팩토리를 캡슐화하여 분리하고, 클라이언트는 이 팩토리에서 반환하는 인스턴트만 신경쓰도록 의존성을 분리한 것.

@@@ FactoryMethod
간단한 팩토리(Simple Factory)를 사용함에 따라 겪게 될 문제를 보완하기 위해, 기존 팩토리인 createPizza를 추상 클래스로 선언하고, 팩토리의 서브클래스를 통해 실제 팩토리를 구현하여 그 내부에서 각 Pizza 객체 생성에 관한 의존성을 관리하도록 나눈 것으로, 복수의 팩토리를 지원, 관리하기 위한 구조.

간단한 팩토리는 일회용에 불과한 반면 팩토리 메소드 패턴을 사용하면 재사용 가능한 프레임워크를 만들 수 있다.

슈퍼클래스(PizzaStore)에 있는 orderPizza 메소드는 요청받게 될 피자에 대한 정보는 전혀 알지 못하며, 인터페이스에 정의되어있는 행위(자르기, 굽기, 포장하기 등)만을 제어한다. 피자의 종류는 선택한 서브클래스에 의해 결정된다.

즉, 팩토리 메소드 패턴은 객체 생성을 서브클래스에 캡슐화할 수 있습니다. 이로 인해 슈퍼클래스에 있는 클라이언트 코드와 서브클래스에 있는 객체 생성 코드(팩토리)를 분리할 수 있게 됩니다.

모든 팩토리 패턴은 객체 생성을 캡슐화한다.
팩토리 메소드 패턴은 서브클래스에서 어떤 클래스를 만들지 결정함으로써 객체 생성을 캡슐화한다. (p.165, p.166 다이어그램 참고)

Creator 추상 클래스에서 객체를 만드는 메소드, 즉 팩토리 메소드용 인터페이스를 제공하기 때문에 팩토리 메소드 패턴이란 이름이 붙은 것이라 생각 됨. (p.168)

@@@ AbstractFactory

팩토리를 통해 인스턴스를 만드는 것 까지는 팩토리 메소드 패턴과 유사하지만 추상 팩토리 패턴은 클라이언트에 보다 큰 비중을 두고 있다.
추상 팩토리 패턴의 목적 자체가 팩토리에서 인스턴스를 생성하는 코드를 인터페이스 기반으로 구성하도록 도와주는 패턴이기에 팩토리 관점에서만 보면 팩토리 메소드 패턴과 유사하지만, 이에 더하여 클라이언트에서 사용하는 부분까지 함께 다루는 패턴이다.
"팩토리 메소드 패턴 + 클라이언트"의 느낌

@@@ 주의 1
인터페이스를 통한 구현이란 꼭 interface/implements 키워드를 통한 구현으로 제한하는 것이 아닌, 디자인 원칙 [2]의 상위 형식에 맞춰 프로그래밍하여 다형성을 적극 활용하는 것을 뜻 한다.

@@@ 주의 2
이 문서에서는 객체와 인스턴스라는 표현이 혼용되어 사용 됨. (가급적 책에서 사용된 표현을 택함)

---

중요한 점은 제품군과 생산부 각각 클래스나 인터페이스를 통한 계층 구조를 확보한 후 이를 클래스화하는 부분, 반드시 추상 클래스나 인터페이스를 통해 구현해야한다는 제한이 있는 것이 아니기 때문에 개발 여건에 따라 다소 변형이 가능.

일종의 의존성주입(디펜던시 인젝션) 이라고 볼수있다. 구현 방식에 따라 다소 차이가 있지만 공통적으로 PizzaStore.orderPizza 내부는 피자에 의존적이지 않은 상태를 유지할 수 있다. (독립적)
orderPizza는 인터페이스로 구현된 pizza를 통해 기술되어, 이후에 피자에 대한 명세가 변경되더라도 orderPizza 코드에는 영향을 주지 않을 수 있어 유연성을 갖게 된다.

[복습]
구체적으로 어떤것을 만들지는 서브클래스가 정한다.

팩토리 메소드 패턴을 적용했을 때의 장점 / 단점
-> 장점
OCP 원칙을 적용하여, 기존 코드를 수정하지 않고 동종의 객체를 쉽게 확장 가능하다
제품군과 생선부 간의 결합도를 느슨하게 결합하였기 때문에 가능

의존성 있는 객체 생성 코드를 한 객체 또는 메소드에 넣어 중복을 방지하고, 관리 포인트를 집중할 수 있다.
인스턴스 생성 시에도 인터페이스만 알고있으면 되므로 유연성과 확장성이 뛰어나다.

-> 단점
각자의 역할을 세세하게 나누기 때문에 클래스(계층)가 많아짐, 복잡도가 올라감

"확장에 열려있고 변경에 닫혀있는 객체 지향 원칙"을 설명하세요.
확장에 열려있다 -> 새로운 기능을 쉽게 확장할 수 있다.
변경에 닫혀있다 -> 기존 코드를 수정하지 않는다.
