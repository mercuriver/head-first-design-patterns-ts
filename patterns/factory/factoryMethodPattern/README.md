# 팩토리 메소드 패턴(Factory Method Pattern)

## 개념

### Head First 디자인 패턴

팩토리 메소드 패턴(Factory Method Pattern)에서는 객체를 생성할 때 필요한 인터페이스를 만듭니다. 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정합니다. 팩토리 메소드 패턴을 사용하면 클래스 인스턴스 만드는 일을 서브클래스에게 맡기게 됩니다.

### GoF의 디자인 패턴

객체를 생성하는 인터페이스는 미리 정의하되, 인스턴스를 만들 클래스의 결정은 서브 클래스 쪽에서 내리는 패턴입니다. 팩토리 메서드 패턴에서는 클래스의 인스턴스를 만드는 시점을 서브클래스로 미룹니다.

## 요약

- 모든 팩토리 패턴은 객체 생성을 캡슐화한다.

- [제품 인터페이스] 제품군의 공통 속성을 정리하여 제품 인터페이스를 정의한다.

- [구상 클래스] 구상 클래스(자식 클래스)는 위에서 정의한 제품 인터페이스를 통해 구현한다.

- [크리에이터] 팩토리 메소드를 포함한 일련의 비즈니스 로직을 품고 있는 추상 클래스로, 팩토리 메소드는 제품 객체를 반환하도록 선언해야 한다. 중요한 것은 팩토리 메소드 내부에서는 구상 클래스를 통한 제품 객체를 생성하되, 반환 타입은 제품 인터페이스와 일치해야 한다. Creator는 제품을 생성하는 것이 아니라, 팩토리 메소드를 통해 제품 구상 클래스와 클라이언트 간 의존성을 분리하는 것을 돕기 위함이다.

- [구상 크리에이터] 위 크리에이터를 상속이나 구현을 통해 팩토리 메소드를 오버라이드하여 각각 다른 제품을 반환하도록 재정의한다.

- 팩토리 메소드를 사용하는 코드를 클라이언트 코드라 부르며, 클라이언트 코드는 사용되는 다양한 자식클래스들을 통해 반환되는 제품 간 차이를 알지 못한다.

- 클라이언트 코드는 모든 제품을 제품군 인터페이스를 통해 다루기 때문에, 이 인터페이스를 통해 호출만 할 뿐, 각 제품별 구상 클래스 내부 동작을 알 필요가 없다.

- 팩토리 메소드는 크리에이터 클래스에서 객체들을 생성할 수 있는 인터페이스를 제공하지만, 구상 크리에이터 클래스들이 생성될 객체들의 유형을 변경할 수 있도록 하는 생성 패턴입니다. 구체적으로 어떤 것을 만들지는 이 구상 크리에이터 클래스가 정한다.

- 팩토리 매소드 패턴의 목적은 어떤 인스턴스 생성의 책임을 구체적인 클래스가 아닌 추상적인 인터페이스의 메소드로 감싸는 것

- 팩토리 메소드는 제품 생성 코드와 제품을 사용하는 코드를 분리하고, 이를 통해 크리에이터 코드를 나머지 코드와 독립되어 확장하기 용이해진다.

- 라이브러리나 프레임워크의 사용자에게 추후 내부 컴포넌트의 확장 가능한 수단을 제공하고 싶을 때 사용하기에 적합하다. 프레임워크 전체에서 컴포넌트 생성하는 코드를 단일 팩토리 메소드로 정리한 후, 사용자에게 이 팩토리 메소드를 오버라이드 할 수 있도록 하는 것이다.

- 팩토리 메소드는 항상 새로운 객체를 생성할 필요는 없다, 기존 객체를 캐시하거나 객체 풀을 사용하는 등 구현법에 따라 차이가 있다.

- 팩토리 메소드 패턴은 구상 크리에이터 클래스(서브클래스)에서 어떤 객체(인스턴스)를 만들지 결정함으로써 객체 생성을 캡슐화한다. (p.165, p.166 다이어그램 참고)

- 크리에이터 추상 클래스에서 객체를 만드는 메소드, 즉 팩토리 메소드용 인터페이스를 제공하기 때문에 팩토리 메소드 패턴이란 이름이 붙은 것이라 생각됨. (p.168)

## 설명

간단한 팩토리(Simple Factory)를 사용함에 따라 겪게 될 문제를 보완하기 위해, 기존 팩토리인 createPizza를 크리에이터(추상 클래스)로 선언하고, 이를 구현하는 구상 크리에이터 클래스(서브클래스)를 통해 실제 팩토리를 구현하여 그 내부에서 각 Pizza 객체 생성에 관한 의존성을 관리하도록 나눈 것.

간단한 팩토리는 일회용에 불과하지만, 팩토리 메소드 패턴을 사용하면 재사용할 수 있는 프레임워크를 만들 수 있다.

슈퍼클래스(PizzaStore)에 있는 orderPizza 메소드는 요청받게 될 피자에 대한 정보는 전혀 알지 못하며, 인터페이스에 정의되어있는 행위(자르기, 굽기, 포장하기 등)만을 제어한다. 피자의 종류는 선택한 구상 크리에이터 클래스에 의해 결정된다.

즉, 팩토리 메소드 패턴은 객체 생성을 구상 크리에이터 클래스에 캡슐화할 수 있습니다. 이에 따라 크리에이터(슈퍼클래스/추상 클래스)에 있는 클라이언트 코드와 구상 크리에이터 클래스(서브클래스)에 있는 객체 생성 코드(팩토리)를 분리할 수 있게 됩니다.

예제에서 팩토리(PizzaStore.createPizza)에서 중요한 것은 객체를 만드는 구상 클래스를 선택하는 것이고, 클라이언트(PizzaStore.orderPizza)는 Pizza 인터페이스를 통해서 반환받은 객체를 사용하기 때문에, 향후 Pizza 인터페이스에 맞추어진 그 어떤 구상 클래스가 orderPizza에서 사용되더라도, orderPizza의 코드를 수정할 필요 없이 유연하게 확장할 수 있게 된다.

객체 구현 방법 변경에 따라 구상 클래스가 수정/확장되더라도, 인터페이스 양식에 변화만 없다면 팩토리 내부에서 다루는 구상 클래스에만 코드 변화가 생길 뿐, 클라이언트는 그 어떤 영향도 받지 않는다.

### 장점

- 크리에이터와 제품 구상 클래스의 결합도를 낮출 수 있다.

- 단일 책임 원칙. 제품 생성 코드를 한곳으로 모아 응집력이 높아진다.

- 개방/폐쇄 원칙. 클라이언트 코드 수정 없이 제품군 수정을 유연하게 할 수 있다. 제품군과 크리에이터 간의 결합도를 느슨하게 결합하였기 때문에 가능한 것

- 의존성 있는 객체 생성 코드를 한 객체 또는 메소드에 넣어 중복을 방지하고, 관리 포인트를 집중할 수 있다.

- 인스턴스 생성 시에도 인터페이스만 알고 있으면 되므로 유연성과 확장성이 뛰어나다.

### 단점

- 새로운 자식 클래스가 많이 추가되므로 복잡도가 높아진다. 가장 좋은 것은 기존 계층구조의 크리에이터 클래스에 팩토리 메소드 패턴을 도입하는 것이다.
