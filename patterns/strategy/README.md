# 전략 패턴 (Strategy Pattern)

## 개념

### Head First 디자인 패턴

전략 패턴(Strategy Pattern)은 알고리즘군을 정의하고 캡슐화해서 각각의 알고리즘군을 수정해서 쓸 수 있게 해줍니다. 전략 패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있습니다.

### GoF의 디자인 패턴

동일 계열의 알고리즘군을 정의하고, 각각의 알고리즘을 캡슐화하며, 이들을 상호 교환이 가능하도록 만드는 패턴입니다. 알고리즘을 사용하는 사용자와 상관없이 독립적으로 알고리즘을 다양하게 변경할 수 있게 합니다.

## 요약

### 패턴 설계 시 주의 사항

- 명세가 변경될 여지가 있는 부분(행동)을 찾아 다른 코드와 독립되도록 `캡슐화`하여 추후 명세 변경에 따른 수정 과정에서 의도치 않게 발생하는 오류를 줄이며 시스템의 유연성을 향상시킨다. (45p)

- 클래스 내에서 행동을 위한 구현에 인터페이스로 사용한다. (47p)

  - 각 행동은 인터페이스로 표현하고 이 인터페이스를 사용하여 행동을 구현한다.
  - 중요한 점은 클래스 내에서 메소드를 통해 행동을 구현하지 않고 다른 클래스에 `위임`한다는 것이다

  즉 행동이 코드 내부에 고정되지 않도록 상위 형식(supertype)에 맞춰 프로그래밍하여 `다형성`을 활용한다.

      상위 형식이란 변수 선언 시 추상 클래스나 인터페이스 같은 상위 형식으로 선언하여 상위 형식에 맞는 구현체의 사용을 허용한다. (48p)

- 행동을 분리하여 디자인하면 다른 형식의 클래스에서도 이 행동을 재사용할 수 있다. (49p)

- 객체지향 관점에서 클래스는 상태와 메소드를 가지고 있으며, 메소드 수준과 동일한 `행동`을 위한 클래스를 작성하는 것이 자칫 어색할 수 있으나, 행동에도 상태와 메소드가 포함되어 있으므로 클래스로 분리되어 작성할 수 있다. (50p)

- 클래스와 행동 클래스의 관계를, 클래스가 행동 클래스를 상속받는 대신, 클래스가 행동 클래스에게 행동을 위임하는 것이 올바른 구성 방식이며, 이를 `구성(composition)`이라 부른다. (59p)
  - 구성을 활용하여 시스템을 디자인하면 유연성이 대폭 향상된다.
- 알고리즘군을 별도의 클래스 집합으로 캡슐화하고, 이를 구성 요소로 사용하는 클래스에서 올바른 인터페이스를 구현한다면 실행 중에도 행동을 변경할 수 있다. (59p)

### 예제 코드 구현 설명

- `추상 클래스 duck`에서 행동을 위임하기 위한 행동 인터페이스 형식의 레퍼런스 변수`FlyBehavior`, `QuackBehavior`2개를 선언한다.
- 인터페이스로 선언된 `FlyBehavior`, `QuackBehavior`는 하위 서브클래스에서 `implements`를 통해 구체적인 행동을 구현한다.
- `추상 클래스 duck`을 상속받은 하위 오리 클래스 내에서 인스턴스 생성 시 사용할 행동 클래스를 구현하고, 행동을 위임한 메소드(`duck.performFly`, `duck.performQuack`)를 호출하여 행동을 요청한다.
- 필요에 따라 행동 클래스를 setter(`duck.setFlyBehavior`, `duck.setQuackBehavior`)를 통해 실행 중에도 행동을 변경 가능하다.
